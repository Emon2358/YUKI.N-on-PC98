name: Build PC-98 Floppy Image (YUKI.N)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y nasm

      - name: Create Assembly Source (UTF-8)
        # BIOSがFDDを読み込む際の挙動に合わせて、セグメント設定を強化しました
        run: |
          cat << 'EOF' > source_utf8.asm
          cpu 8086
          org 0x0000

          section .text
              ; --- セグメント正規化 ---
              ; BIOSによっては CS:IP = 1FC0:0000 などで渡されることがあるため
              ; 強制的に CS=0000 にジャンプします。
              jmp 0x0000:start
          
          start:
              cli
              xor ax, ax
              mov ds, ax
              mov es, ax
              mov ss, ax
              mov sp, 0x7C00 ; スタック位置
              sti

              ; --- 画面モード設定とクリア ---
              ; テキストモードを確実に有効化
              mov ah, 0x0A ; CRTモード設定非表示
              int 0x18
              
              mov ah, 0x16 ; VRAMクリア
              mov dx, 0
              int 0x18

              mov ah, 0x13 ; カーソル初期化
              mov dx, 0
              int 0x18

              ; --- メッセージ表示ループ ---
              mov si, message_data
          
          char_loop:
              lodsb           ; AL = [SI], SI++
              or al, al       ; 終了判定
              jz wait_enter

              ; --- 一文字描画 (INT 18h, AH=40h) ---
              mov ah, 0x40
              mov bx, 0
              int 0x18
              
              ; --- ウェイト ---
              call delay_short

              jmp char_loop

          wait_enter:
              ; --- キー入力待ち ---
              mov ah, 0x00
              int 0x18
              ; Enterキー (CR=0x0D) かチェック
              cmp al, 0x0D
              jne wait_enter

          shutdown:
              ; --- 終了処理 ---
              ; 画面をクリアして停止
              mov ah, 0x16
              mov dx, 0
              int 0x18

              cli
              hlt
          hlt_loop:
              jmp hlt_loop

          ; --- ウェイトルーチン ---
          delay_short:
              push cx
              mov cx, 0x8000  ; 速度調整
          dloop1:
              push cx
              mov cx, 0x0010
          dloop2:
              loop dloop2
              pop cx
              loop dloop1
              pop cx
              ret

          section .data
          ; メッセージ (Shift_JIS変換前)
          message_data:
              db "YUKI.N> これをあなたが読んでいる時、", 0x0D, 0x0A
              db "わたしはわたしではないだろう。", 0x0D, 0x0A
              db 0x0D, 0x0A
              db "YUKI.N> このメッセージが表示されたということは、", 0x0D, 0x0A
              db "そこには、あなた、わたし、涼宮ハルヒ、朝比奈みくる、", 0x0D, 0x0A
              db "古泉一樹が存在しているはずである。", 0x0D, 0x0A
              db 0x0D, 0x0A
              db "YUKI.N> それが鍵。", 0x0D, 0x0A
              db "あなたは解答を見つけ出した。", 0x0D, 0x0A
              db 0x0D, 0x0A
              db "YUKI.N> これは緊急脱出プログラムである。", 0x0D, 0x0A
              db "起動させる場合はエンターキーを、", 0x0D, 0x0A
              db "そうでない場合はそれ以外のキーを選択せよ。", 0x0D, 0x0A
              db 0x0D, 0x0A
              db "YUKI.N> 起動させた場合、", 0x0D, 0x0A
              db "あなたは時空修正の機会を得る。", 0x0D, 0x0A
              db "ただし成功は保証できない。", 0x0D, 0x0A
              db "また帰還の保証もできない。", 0x0D, 0x0A
              db 0x0D, 0x0A
              db "YUKI.N> このプログラムが起動するのは一度きりである。", 0x0D, 0x0A
              db "実行ののち、消去される。", 0x0D, 0x0A
              db "非実行が選択された場合は起動せずに消去される。", 0x0D, 0x0A
              db 0x0D, 0x0A
              db "Ready?", 0
          EOF

      - name: Convert Encoding (UTF-8 to Shift_JIS)
        run: |
          iconv -f UTF-8 -t SHIFT-JIS source_utf8.asm -o yuki.asm

      - name: Assemble
        run: |
          nasm yuki.asm -f bin -o yuki.bin

      - name: Create Floppy Image (2HD)
        # PC-98の標準的なフロッピー形式 (2HD, 1.2MB) のイメージを作成します
        # サイズを 1261568 バイト (1024バイト/セクタ * 8セクタ * 2ヘッド * 77シリンダ) に合わせます
        run: |
          python3 - <<EOF
          disk_size = 1261568
          
          with open('yuki.bin', 'rb') as f:
              code = f.read()
          
          # コードがディスクサイズを超えていないかチェック
          if len(code) > disk_size:
              raise ValueError("Code is too large for the disk image")
          
          # バイナリを書き込み、残りを0x00で埋める
          with open('YUKI_N.fdi', 'wb') as f:
              f.write(code)
              f.write(b'\x00' * (disk_size - len(code)))
              
          print(f"Created YUKI_N.fdi with size {disk_size} bytes")
          EOF

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: YUKI_N_FDI
          path: YUKI_N.fdi
