name: Build Win95 Extractor (Stable Version)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build-win95-watcom:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Open Watcom V2
        run: |
          wget https://github.com/open-watcom/open-watcom-v2/releases/download/Last-CI-build/ow-snapshot.tar.xz
          mkdir watcom
          tar -xf ow-snapshot.tar.xz -C watcom
          chmod +x watcom/binl64/*

      - name: Create C Source Code (Stable & Static Memory)
        run: |
          cat << 'EOF' > extractor.c
          #include <windows.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <string.h>

          #define DEST_DIR "C:\\SAYONARA"
          
          // バッファを静的に確保 (mallocを使わないのでメモリ不足エラーが出ない)
          // 16KBあればWin95でも余裕で動作します
          #define BUF_SIZE 16384
          static unsigned char buffer[BUF_SIZE];

          // 画像データをファイルに書き出す関数
          void WriteImageFile(char *filename, unsigned char *header, int headerSize, FILE *fpIn, long imageSize) {
              FILE *fpOut;
              long remain = imageSize - headerSize;
              long readLen;
              
              // 書き出し開始
              fpOut = fopen(filename, "wb");
              if (!fpOut) return;

              // まずヘッダー部分（バッファにある分）を書き出す
              fwrite(header, 1, headerSize, fpOut);

              // 残りのデータをファイルから読んで書き出す（1バイトずつコピーだと遅いのでバッファ経由）
              while (remain > 0) {
                  readLen = (remain > BUF_SIZE) ? BUF_SIZE : remain;
                  // ファイルから直接読み込む
                  if (fread(buffer, 1, readLen, fpIn) != readLen) break;
                  fwrite(buffer, 1, readLen, fpOut);
                  remain -= readLen;
              }
              fclose(fpOut);
          }

          void ScanAndExtract(char *fname) {
              FILE *fp;
              long fileSize;
              long currentPos = 0;
              int bytesRead;
              int i;
              int count = 0;
              
              // C89対応: 変数宣言は先頭
              unsigned long bmpSize;
              long jpgStart, jpgEnd;
              int j;
              char outName[MAX_PATH];

              fp = fopen(fname, "rb");
              if (!fp) return;

              // ファイルサイズ取得
              fseek(fp, 0, SEEK_END);
              fileSize = ftell(fp);
              fseek(fp, 0, SEEK_SET);

              printf("Scanning: %s\n", fname);

              // メインループ: ファイルを前から順にバッファに読み込む
              while (currentPos < fileSize) {
                  // 現在位置を記憶
                  long loopStartPos = ftell(fp);
                  
                  bytesRead = fread(buffer, 1, BUF_SIZE, fp);
                  if (bytesRead < 4) break;

                  for (i = 0; i < bytesRead - 4; i++) {
                      
                      // --- BMP (BM) 検出 ---
                      if (buffer[i] == 'B' && buffer[i+1] == 'M') {
                          bmpSize = *(unsigned long *)&buffer[i + 2];
                          
                          // サイズ妥当性チェック (誤検出防止)
                          if (bmpSize > 54 && bmpSize < 5000000) {
                              // ファイルからはみ出さないかチェック
                              if (loopStartPos + i + bmpSize <= fileSize) {
                                  sprintf(outName, "%s\\%s_%04d.bmp", DEST_DIR, fname, count++);
                                  printf(" Found BMP: %s\n", outName);

                                  // ファイルポインタを画像の先頭へ移動
                                  fseek(fp, loopStartPos + i, SEEK_SET);
                                  
                                  // 画像として抽出・保存 (この関数内でファイルポインタが進む)
                                  WriteImageFile(outName, NULL, 0, fp, bmpSize);
                                  
                                  // 処理が終わったらループを抜けて、バッファを読み直す
                                  // (ファイルポインタは画像末尾にあるので、そこから再開)
                                  goto RESTART_LOOP;
                              }
                          }
                      }
                      
                      // --- JPEG (FF D8) 検出 ---
                      else if (buffer[i] == 0xFF && buffer[i+1] == 0xD8) {
                          // 簡易チェック
                          if (buffer[i+2] == 0xFF) {
                              sprintf(outName, "%s\\%s_%04d.jpg", DEST_DIR, fname, count++);
                              printf(" Found JPG start: %s\n", outName);
                              
                              // JPEGはサイズが書いてないので、EOI(FF D9)までコピーする特別処理が必要
                              // Win95環境での安定性のため、ここでは固定サイズではなく
                              // 「FF D9が見つかるまで書く」ロジックにする
                              
                              fseek(fp, loopStartPos + i, SEEK_SET);
                              
                              {
                                  FILE *fpOut = fopen(outName, "wb");
                                  int lastByte = 0;
                                  int thisByte;
                                  long safetyCount = 0;
                                  if (fpOut) {
                                      // 1バイトずつコピー (遅いが確実)
                                      while (safetyCount < 1000000) { // 1MB制限
                                          thisByte = fgetc(fp);
                                          if (thisByte == EOF) break;
                                          fputc(thisByte, fpOut);
                                          
                                          if (lastByte == 0xFF && thisByte == 0xD9) {
                                              break; // EOI発見
                                          }
                                          lastByte = thisByte;
                                          safetyCount++;
                                      }
                                      fclose(fpOut);
                                  }
                              }
                              goto RESTART_LOOP;
                          }
                      }
                  }

                  // 何も見つからなければ、次のバッファへ
                  // ただし、ヘッダがバッファ境界で切れるのを防ぐため、少し戻る
                  if (currentPos + bytesRead < fileSize) {
                      fseek(fp, loopStartPos + bytesRead - 64, SEEK_SET);
                  }
                  currentPos = ftell(fp);
                  continue;

              RESTART_LOOP:
                  // 画像抽出後、ここに戻ってくる
                  currentPos = ftell(fp);
              }

              fclose(fp);
          }

          int main() {
              WIN32_FIND_DATA findFileData;
              HANDLE hFind;
              char searchPath[MAX_PATH];

              printf("\n=== SAYONARA EXTRACTOR (Win95 Stable) ===\n");

              if (!CreateDirectory(DEST_DIR, NULL)) {
                  // エラーでも続行
              }
              printf("Save to: %s\n", DEST_DIR);

              GetCurrentDirectory(MAX_PATH, searchPath);
              strcat(searchPath, "\\*.*");

              hFind = FindFirstFile(searchPath, &findFileData);
              if (hFind == INVALID_HANDLE_VALUE) {
                  printf("No files found.\n");
                  getchar();
                  return 1;
              }

              do {
                  if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                      ScanAndExtract(findFileData.cFileName);
                  }
              } while (FindNextFile(hFind, &findFileData));

              FindClose(hFind);
              printf("\nDone! Press Enter to exit.\n");
              getchar();
              return 0;
          }
          EOF

      - name: Compile with Open Watcom
        run: |
          export WATCOM=$PWD/watcom
          export PATH=$WATCOM/binl64:$WATCOM/binw:$PATH
          export INCLUDE=$WATCOM/h:$WATCOM/h/nt
          
          # -os: サイズ最適化
          # -s: スタックサイズ調整 (念のため)
          wcl386 extractor.c -l=nt -3r -os -k8192 -fe=sayonara95.exe

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: SayonaraExtractor-Stable
          path: sayonara95.exe
