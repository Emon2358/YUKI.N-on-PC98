name: PC-98 Auto MIDI Converter

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y nasm
          pip3 install mido

      - name: Convert MIDI to PC-98 Data
        run: |
          python3 - <<EOF
          import mido
          import struct
          import glob
          import os

          # --- 設定 ---
          # PC-98のシステムクロック (2.4576MHz)
          MASTER_CLOCK = 2457600
          # テンポ補正 (エミュレータの速度に合わせて調整してください)
          TIME_SCALE = 30000 

          # --- MIDIファイルの検索 ---
          midi_files = glob.glob('*.mid')
          
          if not midi_files:
              print("No .mid file found. Generating demo.mid...")
              mid = mido.MidiFile()
              track = mido.MidiTrack()
              mid.tracks.append(track)
              # デモ: ドレミファソラシド
              for note in [60, 62, 64, 65, 67, 69, 71, 72]:
                  track.append(mido.Message('note_on', note=note, velocity=64, time=0))
                  track.append(mido.Message('note_off', note=note, velocity=64, time=240))
              mid.save('demo.mid')
              target_midi = 'demo.mid'
          else:
              target_midi = midi_files[0]
              print(f"Found MIDI file: {target_midi}")

          # --- MIDI解析と変換 ---
          # 出力フォーマット: [Counter(2byte)] [WaitCount(2byte)] ... [0,0]
          output_data = bytearray()
          
          # PC-98は単音なので、時間経過を管理しながら単一のトラックにマージします
          mid = mido.MidiFile(target_midi)
          
          # 現在鳴っているノート
          current_note = None
          time_accumulator = 0

          for msg in mid:
              # 時間の累積 (秒単位)
              time_accumulator += msg.time

              if msg.type == 'note_on' and msg.velocity > 0:
                  # --- 前の音(または休符)を書き込む ---
                  wait_count = int(time_accumulator * TIME_SCALE)
                  
                  if wait_count > 0:
                      if current_note is None:
                          # 休符 (Counter=0)
                          output_data += struct.pack('<HH', 0, wait_count)
                      else:
                          # 音符
                          # f = 440 * 2^((note-69)/12)
                          freq = 440 * (2 ** ((current_note - 69) / 12))
                          if freq > 0:
                              counter = int(MASTER_CLOCK / freq)
                              # 16bit範囲内に収める
                              counter = max(1, min(65535, counter))
                              output_data += struct.pack('<HH', counter, wait_count)
                  
                  # 新しい音を開始
                  current_note = msg.note
                  time_accumulator = 0 # 時間リセット

              elif (msg.type == 'note_off') or (msg.type == 'note_on' and msg.velocity == 0):
                  # ノートオフの場合、現在鳴っている音が自分なら音を止める
                  if current_note == msg.note:
                      # --- 今までの音を書き込む ---
                      wait_count = int(time_accumulator * TIME_SCALE)
                      if wait_count > 0:
                          # 音符書き込み
                          freq = 440 * (2 ** ((current_note - 69) / 12))
                          counter = int(MASTER_CLOCK / freq)
                          counter = max(1, min(65535, counter))
                          output_data += struct.pack('<HH', counter, wait_count)
                      
                      current_note = None # 音なし状態へ
                      time_accumulator = 0

          # 最後の余韻
          wait_count = int(time_accumulator * TIME_SCALE)
          if wait_count > 0:
              if current_note:
                  freq = 440 * (2 ** ((current_note - 69) / 12))
                  counter = int(MASTER_CLOCK / freq)
                  output_data += struct.pack('<HH', counter, wait_count)
              else:
                  output_data += struct.pack('<HH', 0, wait_count)

          # 終了マーカー
          output_data += struct.pack('<HH', 0, 0)

          with open('music.bin', 'wb') as f:
              f.write(output_data)
          
          print(f"Conversion Complete. Binary size: {len(output_data)} bytes")
          EOF

      - name: Create Assembly Player
        run: |
          cat << 'EOF' > player.asm
          cpu 8086
          org 0x0000

          section .text
          start:
              cli
              mov ax, cs
              mov ds, ax
              mov es, ax
              mov ss, ax
              mov sp, 0xFFFE
              sti

              ; --- 画面設定 (黒背景・文字表示) ---
              mov ah, 0x0A
              mov al, 0x00
              int 0x18
              mov ah, 0x16
              mov dx, 0
              int 0x18
              mov ah, 0x13
              mov dx, 1
              mov cx, 0x0000
              int 0x18

              ; --- タイトル表示 ---
              mov si, title_msg
              call print_string

              ; --- 再生開始 ---
              mov si, music_data
          
          play_loop:
              ; データ読み込み [Counter(2)][Wait(2)]
              lodsw           ; AX = Counter
              mov bx, ax
              lodsw           ; AX = WaitCount
              mov cx, ax

              ; 終了判定 (両方0)
              mov dx, bx
              or dx, cx
              jz stop_music

              ; 音程判定 (Counter=0 は休符)
              cmp bx, 0
              je silence

              ; --- 音を鳴らす (PIT設定) ---
              push ax
              
              ; 1. Beep ON (Port 37h bit3=1)
              mov dx, 0x37
              mov al, 0x06
              out dx, al

              ; 2. PIT Mode (Counter 1, Square Wave)
              mov dx, 0x77
              mov al, 0x76
              out dx, al

              ; 3. Frequency Data
              mov dx, 0x73
              mov al, bl      ; Low Byte
              out dx, al
              mov al, bh      ; High Byte
              out dx, al
              
              pop ax
              jmp do_wait

          silence:
              ; 音を止める
              mov dx, 0x37
              mov al, 0x0F
              out dx, al

          do_wait:
              ; ウェイト処理 (CX回ループ)
              ; I/Oポートアクセスで時間を稼ぐ
          wait_loop:
              in al, 0x60
              loop wait_loop

              jmp play_loop

          stop_music:
              ; 完全に音を止める
              mov dx, 0x37
              mov al, 0x0F
              out dx, al
              
              ; 完了メッセージ
              mov si, done_msg
              call print_string
              
          halt_cpu:
              cli
              hlt
              jmp halt_cpu

          ; --- 文字列表示ルーチン ---
          print_string:
              mov ah, 0x40
              mov bx, 0
          .p_loop:
              lodsb
              or al, al
              jz .ret
              int 0x18
              jmp .p_loop
          .ret:
              ret

          section .data
          title_msg:
              db "PC-98 MIDI PLAYER", 0x0D, 0x0A
              db "Converting and Playing...", 0x0D, 0x0A, 0
          
          done_msg:
              db 0x0D, 0x0A, "Playback Finished.", 0x0D, 0x0A, 0

          ; Pythonで変換した音楽データを取り込む
          music_data:
              incbin "music.bin"
          EOF

      - name: Assemble
        run: nasm player.asm -f bin -o player.bin

      - name: Create Bootable Disk (HDM)
        run: |
          python3 - <<EOF
          disk_size = 1261568
          with open('player.bin', 'rb') as f:
              code = f.read()
          
          # 容量チェック
          if len(code) > disk_size:
              print("Warning: MIDI data is too large for floppy disk!")
          
          padding = b'\x00' * (disk_size - len(code))
          with open('PLAYER.hdm', 'wb') as f:
              f.write(code)
              f.write(padding)
          EOF

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: PC98_MIDI_PLAYER
          path: PLAYER.hdm
