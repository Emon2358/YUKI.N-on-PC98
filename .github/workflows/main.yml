name: Build PC-98 Embedded Font Graphic

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Install Dependencies
        # 画像処理ライブラリ(Pillow)と、日本語フォント(Noto Sans)をインストール
        run: |
          sudo apt-get update
          sudo apt-get install -y nasm python3-pil fonts-noto-cjk

      - name: Generate VRAM Data (Python)
        # ここで「文字の画像」を作ります
        run: |
          python3 - <<EOF
          from PIL import Image, ImageDraw, ImageFont
          import struct

          # PC-98の画面サイズ (640x400)
          WIDTH, HEIGHT = 640, 400
          
          # 画像を作成 (1bitモノクロ: 0=黒, 1=白)
          image = Image.new("1", (WIDTH, HEIGHT), 0)
          draw = ImageDraw.Draw(image)
          
          # フォント読み込み (Ubuntuに入れたNotoSansを使用)
          # サイズは16px (PC-98の標準的な文字サイズに近い)
          try:
              font = ImageFont.truetype("/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc", 16)
          except:
              # フォールバック
              font = ImageFont.load_default()

          # 表示するメッセージ
          text = """
          YUKI.N> これをあなたが読んでいる時、
          わたしはわたしではないだろう。
          
          YUKI.N> このメッセージが表示されたということは、
          そこには、あなた、わたし、涼宮ハルヒ、朝比奈みくる、
          古泉一樹が存在しているはずである。
          
          YUKI.N> それが鍵。
          あなたは解答を見つけ出した。
          
          YUKI.N> これは緊急脱出プログラムである。
          起動させる場合はエンターキーを、
          そうでない場合はそれ以外のキーを選択せよ。
          
          YUKI.N> 起動させた場合、
          あなたは時空修正の機会を得る。
          ただし成功は保証できない。
          また帰還の保証もできない。
          
          YUKI.N> このプログラムが起動するのは一度きりである。
          実行ののち、消去される。
          
          Ready?
          """

          # 文字を描画 (位置は左上 (0,0) から)
          # 行間を少し空けて読みやすくします
          y_text = 10
          for line in text.split('\n'):
              draw.text((10, y_text), line, font=font, fill=1)
              y_text += 20 # 行送り

          # --- PC-98 VRAM形式への変換 ---
          # PC-98のグラフィックVRAMは「プレーン方式」です。
          # 1バイトに横8ピクセルが詰まっています。
          # Pythonの tobytes("raw") は1ピクセル1バイトになりがちなので、
          # 1bitパック形式に変換する必要があります。
          
          # image.tobytes() for mode '1' packs 8 pixels per byte, which is what we want!
          # ただし、PC-98のVRAM構造に合わせて配置する必要があります。
          
          raw_data = image.tobytes()
          
          # ファイルに保存
          with open('vram.bin', 'wb') as f:
              f.write(raw_data)
              
          print(f"Generated vram.bin size: {len(raw_data)} bytes")
          EOF

      - name: Create Assembly Source
        run: |
          cat << 'EOF' > loader.asm
          cpu 8086
          org 0x0000

          section .text
          start:
              cli
              mov ax, cs
              mov ds, ax
              mov es, ax
              mov ss, ax
              mov sp, 0xFFFE
              sti

              ; --- 1. グラフィックモード設定 (640x400 Color) ---
              mov ah, 0x42    ; Set Mode
              mov ch, 0xC0    ; 640x400 Color Mode
              int 0x18

              ; --- 2. 画面表示ON ---
              mov ah, 0x40    ; Display Control
              mov al, 0x00    ; Show
              int 0x18
              
              ; --- 3. VRAM転送 (画像の表示) ---
              ; 作成した vram.bin (32000バイト) を
              ; 青(B), 赤(R), 緑(G) の3つのプレーン全てに書き込みます。
              ; 光の三原色ですべて書き込むと「白」になります。

              ; コピー元のデータアドレス
              mov si, vram_image

              ; -- Blue Plane (A800) --
              mov ax, 0xA800
              mov es, ax
              call copy_plane

              ; -- Red Plane (B000) --
              mov ax, 0xB000
              mov es, ax
              call copy_plane

              ; -- Green Plane (B800) --
              mov ax, 0xB800
              mov es, ax
              call copy_plane

              ; --- 4. 完了ループ ---
          halt_loop:
              cli
              hlt
              jmp halt_loop

              ; --- サブルーチン: 1プレーン分(32000バイト)コピー ---
          copy_plane:
              push si         ; SI(元データ)を保存しておく
              xor di, di      ; 書き込み先は 0x0000 から
              mov cx, 32000   ; 画面全体のバイト数 (640*400/8)
              
              ; 高速転送 (MOVSB)
              rep movsb
              
              pop si          ; SIを復帰 (次のプレーンのために)
              ret

          section .data
          ; Pythonで作った画像データをここに埋め込む
          vram_image:
              incbin "vram.bin"
          EOF

      - name: Assemble
        run: nasm loader.asm -f bin -o yuki.bin

      - name: Create HDM Image
        run: |
          python3 - <<EOF
          disk_size = 1261568
          with open('yuki.bin', 'rb') as f:
              code = f.read()
          
          # サイズチェック (フロッピーに入るか)
          print(f"Code size: {len(code)} bytes")
          if len(code) > disk_size:
              raise Exception("Error: Image is too large for floppy disk!")

          padding = b'\x00' * (disk_size - len(code))
          with open('YUKI_N.hdm', 'wb') as f:
              f.write(code)
              f.write(padding)
          EOF

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: YUKI_N_GraphicFont
          path: YUKI_N.hdm
